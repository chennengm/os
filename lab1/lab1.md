# <center> Lab0实验报告
姓名：安怡然 学号：2213393

姓名：郭笑语 学号：2211392

姓名：翟乐炜 学号：2213469

## 练习 1:使用GDB验证启动流程
实验要求：为了熟悉使用 qemu 和 gdb 进行调试工作, 使用 gdb 调试 QEMU 模拟的 RISC-V 计算机加电开始运行到执行
应用程序的第一条指令（即跳转到0x80200000）这个阶段的执行过程，说明 RISC-V 硬件加电后的几条指令
在哪里？完成了哪些功能？

首先我们打开三个命令窗口，分别输入以下三个命令
```
$ make qemu
$ make debug
$ make gdb
```
成功启动程序后，在启动gdb的窗口中输入
```
x/i $pc
```
来获取当前的程序计数器位置
```
(gdb) x/i $pc
=> 0x1000:	auipc	t0,0x0
```
可以看到当前指令的pc是0x1000，此处的指令是auipc t0,0x0 ，用于将一个立即数0添加到 PC 寄存器的值上来设置寄存器 t0

我们查看0x1000的附近十条指令，可以看到程序在0x1010处进行了跳转
```
(gdb) x/10i 0x1000    
   0x1000:	auipc	t0,0x0
   0x1004:	addi	a1,t0,32
   0x1008:	csrr	a0,mhartid
   0x100c:	ld	t0,24(t0)
   0x1010:	jr	t0
   0x1014:	unimp
   0x1016:	unimp
   0x1018:	unimp
   0x101a:	0x8000
   0x101c:	unimp
```
我们逐步调试代码，跟踪跳转位置
```
(gdb) si
0x0000000000001004 in ?? ()
(gdb) si
0x0000000000001008 in ?? ()
(gdb) si
0x000000000000100c in ?? ()
(gdb) si
0x0000000000001010 in ?? ()
(gdb) si
0x0000000080000000 in ?? ()
```
可以看到代码在0x1010处跳转到了0x80000000 处，验证了在 QEMU 模拟的这款 riscv 处理器中，将复位地址初始化为 0x1000，再将PC初始化为该复位地址，因此处理器将从此处开始执行复位代码，并且会在0x80000000启动 Bootloader，Bootloader 将加载操作系统内核并启动操作系统的执行。

阅读实验手册可以得知，在0x80000000开始执行bootloader的代码时，操作系统的内核加载到地址中，之后跳转到0x80200000去，接下来操作系统的二进制可执行文件被OpenSBI加载到内存中，然后 OpenSBI会把CPU的”当前指令指针”(pc, program counter)跳转到内存里的一个位置，开始执行内存中那个位置的指令。

为了验证验证程序是否跳转到操作系统的入口点 0x80200000。设置断点并继续执行
```
(gdb) break *0x80200000
Breakpoint 1 at 0x80200000: file kern/init/entry.S, line 7.
(gdb) continue
Continuing.

Breakpoint 1, kern_entry () at kern/init/entry.S:7
7	    la sp, bootstacktop
```
可以看到程序成功在 0x80200000 处设置断点并跳转到操作系统的入口点 kern_entry 函数，接过计算机的控制权，并且在内核中分配内存栈。然后跳转到 kern_init这个真正的入口点，并且debug窗口出现了输出，验证了内核启动的完整过程。

![alt text](image.png)




## 学到的知识点

### 逐步熟悉了gdb的使用方法。

– x/10i 0x80000000 : 显示 0x80000000 处的 10 条汇编指令。

– x/10i $pc : 显示即将执行的 10 条汇编指令。

– x/10xw 0x80000000 : 显示 0x80000000 处的 10 条数据，格式为 16 进制 32bit。

– info register: 显示当前所有寄存器信息。

– info r t0: 显示 t0 寄存器的值。

– break funcname: 在目标函数第一条指令处设置断点。

– break *0x80200000: 在 0x80200000 处设置断点。

– continue: 执行直到碰到断点。

– si: 单步执行一条汇编指令

### 熟悉了内核启动流程。
1.硬件启动：当计算机加电后，处理器从一个预定义的复位地址（如 RISC-V 的 0x1000开始执行指令。此时，处理器首先执行一系列初始化操作，如设置寄存器、内存地址等。

2.引导程序加载（Bootloader）：处理器执行引导程序，它负责将操作系统内核从存储设备（如硬盘或内存）加载到内存中。在 RISC-V 架构下，引导程序通常会跳转到 0x80000000 地址处的 Bootloader。Bootloader 会初始化硬件环境，如设置内存和CPU状态，然后将内核加载到内存中的特定位置（如 0x80200000），并将控制权交给内核。

3.内核初始化：当引导程序完成后，内核开始执行。内核的入口点（如 kern_entry）设置堆栈指针并进行基础的硬件配置。接着，内核初始化重要的系统组件，如内存管理、设备驱动程序和中断处理程序，最后启动调度程序以开始运行用户态程序。


# <center> Lab1实验报告

## 练习 1:理解内核启动中的程序入口操作
阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ 
tail kern_init 完成了什么操作，目的是什么？

指令la sp,bootstacktop的意思是，将bootstacktop的地址加载到栈指针sp中，使内核得以使用栈。

tail kern_init中，tail为一种调用约定，用于不会返回到调用者的函数，此处kern_init为内核初始化函数，即跳转到初始化函数，且不返回。

## 练习2：完善中断处理 （需要编程）
请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写kern/trap/trap.c函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”，在打印完10行后调用sbi.h中的shut_down()函数关机。
要求完成问题1提出的相关函数实现，提交改进后的源代码包（可以编译执行），并在实验报告中简要说明实现过程和定时器中断处理的流程。实现要求的部分代码后，运行整个系统，大约每1秒会输出一次”100 ticks”，输出10行。

完善中断处理函数
```
case IRQ_S_TIMER:
            clock_set_next_event();
            if (++ticks % TICK_NUM == 0)
            {
                print_ticks();
            }
            break;
```
调用clock_set_next_event()函数设置下一次时钟中断事件，判断ticks+1是否为100，即是否遇到了100次时钟中断，如果是，则调用print_ticks()函数，输出“100 ticks”

定时器中断处理的流程为：
set_sbi_timer()函数通过OpenSBI的时钟事件触发中断，之后跳转到trapentry.S的__alltraps，保存上下文，并跳转到trap.c的中断处理函数trap()。
trap()函数参数为切换前上下文的结构体，调用trap_dispatch函数，将中断异常和异常处理的工作分发给两个函数interrupt_handler和exception_handler。
interrupt_handler函数根据中断类型，输出对应文字，且对于用户软件的计时器中断，进行计数器的累加，设置下一次时钟中断。
中断处理结束后，返回trapentry.S，执行__trapret中的内容——恢复之前保存的寄存器和状态信息，从中断返回到用户态。

## 重要的知识点

### 中断与中断处理的过程

– 一般方法：编写中断处理代码->正确设置控制寄存器->CPU捕获异常->将控制权转交给中断处理代码->返回正在运行的程序
– 中断分为：异常——执行指令时发生错误；
                     陷入——主动通过指令停下来，并跳转到处理函数；
                     中断——CPU被外设的信号打断，需要暂停处理外设。
                     （后两者在RISCV中统称为trap）
– 寄存器：通用寄存器与控制状态寄存器（CSRs）
– 上下文的概念，与切换机制：保存与恢复
– 时钟中断的具体实现：
   确认时钟中断的触发频率->根据OpenSBI的接口，每次发生中断时，设置下一次的时钟中断->每触发100次时钟中断，输出一行文字

## 扩展练习 Challenge1：描述与理解中断流程

### ucore中处理中断异常的流程

#### 1.出现异常
异常的产生是因为在执行指令的过程中发生了错误，例如访问无效内存地址、执行非法指令、发生缺页等。而出现异常时，一般会通过中断进行处理（异常也是中断的一种），进而把控制权转交给对应的具有更高权限的中断处理程序来进行错误处理。

#### 2.CPU跳向中断入口点并保存上下文
中断产生后，CPU需要找到中断处理程序来处理中断，所以CPU会先跳向stvec（中断向量表基址），再通过stvec跳到中断处理程序的入口点。而为了保证异常处理后可以继续原有工作，还需要对上下文进行保存，即将CPU的寄存器（上下文）保存到内存中（栈上）。所以在找到中断入口点后，会使用定义好的汇编宏SAVE_ALL保存所有寄存器到栈顶，并把上下文包装成结构体送入对应中断处理程序。另外，当触发中断进入S态进行处理时，sepc（记录触发中断的那条指令的地址）、scause（记录中断发生的原因、是否是外部中断）和stval（记录辅助信息）寄存器会被硬件自动设置，从而将信息提供给中断处理程序。

#### 3.进入中断处理程序
保存完上下文信息后，会使用jal trap正式转入对应的中断处理程序。在此前已经完成了中断的初始化过程。接下来会根据scause将异常处理的工作分发给interrupt_handler()，exception_handler(), 这些函数再根据中断或异常的不同类型来进行对应处理。

#### 4.恢复上下文
当中断或异常处理完成后，会对寄存器的状态进行恢复，即将保存在内核栈上的上下文信息进行恢复，并使用等特权指令返回到原始的程序执行点继续进行执行。


### mov a0，sp的目的

其主要目的是进行参数传递。因为根据sp可以确定其他寄存器数值保存的位置，所以获得了sp的值相当于获得了上下文信息。将sp的值存入a0作为参数，然后调用trap，可以使中断处理程序获得上下文信息。

### SAVE_ALL中寄存器保存在栈中的位置的确定方法

保存过程为，先使用csrw sscratch，sp将原先的栈顶指针保存到到sscratch，然后开辟栈空间，保存通用寄存器和读入通用寄存器中的CSR。为解释保存方式，以STORE x3, 3\*REGBYTES(sp)为例，这行指令表示将x3寄存器的值存储到栈中sp偏移量为3\*REGBYTES 的位置。

如果想确定其位置，结合sp、寄存器编号和REGBYTES即可知道。特别的，sscratch保存在偏移量为2\*REGBYTES处，其余CSR在偏移量为32、*REGBYTES及之后处。

### 对于任何中断，__alltraps 中都需要保存所有寄存器吗？
不一定。大多数情况下，__alltraps会选择保存所有寄存器，但有时为了性能优化或根据设计简化流程，会只保存会在处理中断或异常过程中被修改的寄存器。同时，由于x0寄存器的值始终为0，所以省略其保存过程也是可行的，在恢复时并未恢复x0寄存器也印证了这一点。

## 扩增练习 Challenge2：理解上下文切换机制

### csrw sscratch, sp；csrrw s0, sscratch, x0实现的操作与目的

csrw sscratch, sp的操作为将sp的值写入sscratch寄存器中。其目的时保存原先的栈顶指针（开辟栈空间前的），随后这个值将通过通用寄存器存入sp偏移2\*REGBYTES处（这里的sp值是进行过addi sp, sp, -36 * REGBYTES操作的sp值）。在恢复上下文时，会对其进行恢复，确保确保异常处理后能恢复当前的栈指针。

csrrw s0, sscratch, x0的操作为从sscratch读取旧值并将其保存到 s0寄存器中，再将x0（即0）写入sscratch寄存器，覆盖sscratch中的原始值。其第一步的目的是将sp值先存入通用寄存器，以便后续存入栈中，第二步的目的是为了防止使用过期的寄存器值，sscratch设为0可以表示当前在内核中运行。例如如果在异常处理程序中出现了异常，sscratch的值为0可以使异常向量知道异常来自内核，即并且可能出现了递归异常，从而进行处理防止处理器反复陷入异常处理程序。

### save all里面保存了stval scause这些csr，而在restore all里面却不还原它们，store的意义是什么？

save all中保存stval scause这些csr是为了将信息提供给异常处理程序，而在异常处理程序中这些信息已经被使用过了，其对程序继续正常运行没有作用，所以不需要恢复。

## 扩展练习Challenge3：完善异常中断

为了触发非法指令和断点的异常指令，通过内联汇编加入如下内容
```
    asm volatile("mret");
    asm volatile("ebreak");
```
然后完善异常处理，添加所要求的输出并通过epc（储存了sepc的值）获取异常指令触发地址，并更新tf->epc寄存器值（以越过异常发生的地址），代码如下
```
   case CAUSE_ILLEGAL_INSTRUCTION:
            cprintf("Exception type:Illegal instruction\n");
            cprintf("Illegal instruction caught at 0x%p\n",tf->epc);
            tf->epc+=4;
            break;
   case CAUSE_BREAKPOINT:
            cprintf("Exception type:breakpoint\n");
            cprintf("breakpoint caught at 0x%p\n",tf->epc);
            tf->epc+=2;
            break;
```
