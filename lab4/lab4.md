# lab4æ“ä½œç³»ç»Ÿ

# Lab4è¿›ç¨‹ç®¡ç†

---

å®‰æ€¡ç„¶ 2213393 ç¿Ÿä¹ç‚œ2213469 éƒ­ç¬‘è¯­ 2211392

# 1. å®éªŒç›®çš„

- äº†è§£å†…æ ¸çº¿ç¨‹åˆ›å»º/æ‰§è¡Œçš„ç®¡ç†è¿‡ç¨‹
- äº†è§£å†…æ ¸çº¿ç¨‹çš„åˆ‡æ¢å’ŒåŸºæœ¬è°ƒåº¦è¿‡ç¨‹

# 2. å®éªŒå†…å®¹

å®éªŒ 2/3 å®Œæˆäº†ç‰©ç†å’Œè™šæ‹Ÿå†…å­˜ç®¡ç†ï¼Œè¿™ç»™åˆ›å»ºå†…æ ¸çº¿ç¨‹ï¼ˆå†…æ ¸çº¿ç¨‹æ˜¯ä¸€ç§ç‰¹æ®Šçš„è¿›ç¨‹ï¼‰æ‰“ä¸‹äº†æä¾›å†…å­˜ç®¡
ç†çš„åŸºç¡€ã€‚å½“ä¸€ä¸ªç¨‹åºåŠ è½½åˆ°å†…å­˜ä¸­è¿è¡Œæ—¶ï¼Œé¦–å…ˆé€šè¿‡ ucore OS çš„å†…å­˜ç®¡ç†å­ç³»ç»Ÿåˆ†é…åˆé€‚çš„ç©ºé—´ï¼Œç„¶åå°±
éœ€è¦è€ƒè™‘å¦‚ä½•åˆ†æ—¶ä½¿ç”¨ CPU æ¥â€œå¹¶å‘â€æ‰§è¡Œå¤šä¸ªç¨‹åºï¼Œè®©æ¯ä¸ªè¿è¡Œçš„ç¨‹åºï¼ˆè¿™é‡Œç”¨çº¿ç¨‹æˆ–è¿›ç¨‹è¡¨ç¤ºï¼‰â€œæ„Ÿåˆ°â€
å®ƒä»¬å„è‡ªæ‹¥æœ‰â€œè‡ªå·±â€çš„ CPUã€‚
æœ¬æ¬¡å®éªŒå°†é¦–å…ˆæ¥è§¦çš„æ˜¯å†…æ ¸çº¿ç¨‹çš„ç®¡ç†ã€‚å†…æ ¸çº¿ç¨‹æ˜¯ä¸€ç§ç‰¹æ®Šçš„è¿›ç¨‹ï¼Œå†…æ ¸çº¿ç¨‹ä¸ç”¨æˆ·è¿›ç¨‹çš„åŒºåˆ«æœ‰ä¸¤ä¸ªï¼š
â€¢ å†…æ ¸çº¿ç¨‹åªè¿è¡Œåœ¨å†…æ ¸æ€
â€¢ ç”¨æˆ·è¿›ç¨‹ä¼šåœ¨åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€äº¤æ›¿è¿è¡Œ
â€¢ æ‰€æœ‰å†…æ ¸çº¿ç¨‹å…±ç”¨ ucore å†…æ ¸å†…å­˜ç©ºé—´ï¼Œä¸éœ€ä¸ºæ¯ä¸ªå†…æ ¸çº¿ç¨‹ç»´æŠ¤å•ç‹¬çš„å†…å­˜ç©ºé—´
â€¢ è€Œç”¨æˆ·è¿›ç¨‹éœ€è¦ç»´æŠ¤å„è‡ªçš„ç”¨æˆ·å†…å­˜ç©ºé—´
ç›¸å…³åŸç†ä»‹ç»å¯çœ‹é™„å½• Bï¼šã€åŸç†ã€‘è¿›ç¨‹/çº¿ç¨‹çš„å±æ€§ä¸ç‰¹å¾è§£æã€‚.. _ æå‰è¯´æ˜

### ç»ƒä¹ 1ï¼š**åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å—ï¼ˆéœ€è¦ç¼–ç ï¼‰**

> alloc_proc å‡½æ•°ï¼ˆä½äº kern/process/proc.c ä¸­ï¼‰è´Ÿè´£åˆ†é…å¹¶è¿”å›ä¸€ä¸ªæ–°çš„ struct proc_struct ç»“æ„ï¼Œç”¨äºå­˜å‚¨æ–°å»ºç«‹çš„å†…æ ¸çº¿ç¨‹çš„ç®¡ç†ä¿¡æ¯ã€‚ucore éœ€è¦å¯¹è¿™ä¸ªç»“æ„è¿›è¡Œæœ€åŸºæœ¬çš„åˆå§‹åŒ–ï¼Œä½ éœ€è¦å®Œæˆè¿™ä¸ªåˆå§‹åŒ–è¿‡ç¨‹ã€‚
ã€æç¤ºã€‘åœ¨ alloc_proc å‡½æ•°çš„å®ç°ä¸­ï¼Œéœ€è¦åˆå§‹åŒ–çš„ proc_struct ç»“æ„ä¸­çš„æˆå‘˜å˜é‡è‡³å°‘åŒ…æ‹¬ï¼š
state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/nameã€‚
è¯·åœ¨å®éªŒæŠ¥å‘Šä¸­ç®€è¦è¯´æ˜ä½ çš„è®¾è®¡å®ç°è¿‡ç¨‹ã€‚è¯·å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š
â€¢ è¯·è¯´æ˜ proc_struct ä¸­ struct context context å’Œ struct trapframe *tf æˆå‘˜å˜é‡å«ä¹‰å’Œ
åœ¨æœ¬å®éªŒä¸­çš„ä½œç”¨æ˜¯å•¥ï¼Ÿï¼ˆæç¤ºé€šè¿‡çœ‹ä»£ç å’Œç¼–ç¨‹è°ƒè¯•å¯ä»¥åˆ¤æ–­å‡ºæ¥ï¼‰
> 

ç”±æç¤ºä¿¡æ¯å¯çŸ¥proc_structç»“æ„ä½“ä¸­é™¤äº†ï¼Œlist_entry_t list_link;å’Œlist_entry_t hash_link;ä¸¤ä¸ªå˜é‡ä¹‹å¤–éƒ½éœ€è¦åˆå§‹åŒ–ã€‚

```c
struct proc_struct {
enum proc_state state;                      // è¿›ç¨‹çŠ¶æ€
int pid;                                    // è¿›ç¨‹ID
int runs;                                   // è¿›ç¨‹è¢«è°ƒåº¦è¿è¡Œçš„æ¬¡æ•°
uintptr_t kstack;                           // è¿›ç¨‹å†…æ ¸æ ˆæŒ‡é’ˆ
volatile bool need_resched;                 // æ˜¯å¦éœ€è¦é‡æ–°è°ƒåº¦
struct proc_struct *parent;                 // the parent process
struct mm_struct *mm;                       // è¿›ç¨‹çš„å†…å­˜ç®¡ç†ç»“æ„
struct context context;                     // è¿›ç¨‹çš„CPUä¸Šä¸‹æ–‡
struct trapframe *tf;                       // ä¸­æ–­å¸§æŒ‡é’ˆ
uintptr_t cr3;                              // é¡µç›®å½•è¡¨PDTçš„åŸºå€
uint32_t flags;                             // è¿›ç¨‹æ ‡å¿—ä½
char name[PROC_NAME_LEN + 1];               // è¿›ç¨‹åç§°
list_entry_t list_link;                     // å…¨å±€è¿›ç¨‹é“¾è¡¨ä¸­çš„èŠ‚ç‚¹
list_entry_t hash_link;                     // å“ˆå¸Œé“¾è¡¨ä¸­çš„èŠ‚ç‚¹
};
...
static struct proc_struct *
alloc_proc(void) {
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL) {
    //LAB4:EXERCISE1 YOUR CODE
        proc->state = PROC_UNINIT;//åˆå§‹çŠ¶æ€ä¸ºæœªåˆå§‹åŒ–
        proc->pid = -1;//pidä¸ºæœªèµ‹å€¼
        proc->runs = 0;//è¿è¡Œæ¬¡æ•°åˆå§‹ä¸º 0
        proc->kstack = 0;//é™¤äº†idleprocå…¶ä»–çº¿ç¨‹çš„å†…æ ¸æ ˆéƒ½è¦åç»­åˆ†é…
        proc->need_resched =0; // ä¸éœ€è¦ç«‹å³è°ƒåº¦åˆ‡æ¢çº¿ç¨‹
        proc->parent = NULL;//æ²¡æœ‰çˆ¶çº¿ç¨‹
        proc->mm = NULL;//æœªåˆ†é…å†…å­˜
        memset(&(proc->context), 0, sizeof(struct context));// æ¸…ç©ºä¸Šä¸‹æ–‡
        proc->tf = NULL; //ä¸­æ–­å¸§æŒ‡é’ˆæœªåˆ†é…
        proc->cr3 = boot_cr3;//å†…æ ¸çº¿ç¨‹çš„cr3ä¸ºboot_cr3ï¼Œå³é¡µç›®å½•ä¸ºå†…æ ¸é¡µç›®å½•è¡¨
        proc->flags = 0;// è¿›ç¨‹æ ‡å¿—ä½åˆå§‹åŒ–ä¸º 0
        memset(proc->name, 0, PROC_NAME_LEN+1);// è¿›ç¨‹åæ¸…ç©º
    }
    return proc;
}
```

- struct context context

```c
/ä¸Šä¸‹æ–‡ç»“æ„
struct context {
uintptr_t ra;// è¿”å›åœ°å€
uintptr_t sp;// æ ˆæŒ‡é’ˆ
uintptr_t s0;// s0-11è¢«è°ƒç”¨è€…ä¿å­˜çš„å¯„å­˜å™¨
uintptr_t s1;
uintptr_t s2;
uintptr_t s3;
uintptr_t s4;
uintptr_t s5;
uintptr_t s6;
uintptr_t s7;
uintptr_t s8;
uintptr_t s9;
uintptr_t s10;
uintptr_t s11;
};
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œstruct context æ˜¯ç”¨äºä¿å­˜å’Œæ¢å¤è¿›ç¨‹è¿è¡Œæ—¶ CPU ä¸Šä¸‹æ–‡çš„ç»“æ„ä½“ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½åŒ…å«ä¸€ä¸ª context å­—æ®µï¼Œç”¨äºä¿å­˜è¯¥è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚

æ“ä½œç³»ç»Ÿæ”¯æŒå¤šè¿›ç¨‹è¿è¡Œæ—¶ï¼Œéœ€è¦é€šè¿‡è°ƒåº¦å™¨åœ¨å¤šä¸ªè¿›ç¨‹ä¹‹é—´åˆ‡æ¢ã€‚å½“åˆ‡æ¢æ—¶ï¼Œå½“å‰è¿›ç¨‹çš„è¿è¡ŒçŠ¶æ€ï¼ˆå¯„å­˜å™¨ã€æ ˆæŒ‡é’ˆç­‰ï¼‰éœ€è¦ä¿å­˜ï¼Œä»¥ä¾¿åç»­èƒ½ç»§ç»­æ‰§è¡Œã€‚åœ¨è¿›ç¨‹åˆ‡æ¢æ—¶ï¼Œå½“å‰è¿›ç¨‹çš„å¯„å­˜å™¨å†…å®¹ä¼šä¿å­˜åˆ°å…¶ context ä¸­ï¼Œå½“è°ƒåº¦å™¨åˆ‡æ¢å›æŸä¸ªè¿›ç¨‹æ—¶ï¼Œéœ€è¦å°†ä¿å­˜çš„ä¸Šä¸‹æ–‡æ¢å¤åˆ° CPUã€‚é€šè¿‡å°† context ä¸­ä¿å­˜çš„å¯„å­˜å™¨å€¼åŠ è½½å› CPUï¼Œè¿›ç¨‹å¯ä»¥ä»åˆ‡æ¢å‰çš„çŠ¶æ€ç»§ç»­æ‰§è¡Œã€‚

- struct trapframe *tf

```c
struct pushregs {
uintptr_t zero;  // Hard-wired zero
uintptr_t ra;    // Return address
uintptr_t sp;    // Stack pointer
uintptr_t gp;    // Global pointer
uintptr_t tp;    // Thread pointer
uintptr_t t0;    // Temporary
uintptr_t t1;    // Temporary
uintptr_t t2;    // Temporary
uintptr_t s0;    // Saved register/frame pointer
uintptr_t s1;    // Saved register
uintptr_t a0;    // Function argument/return value
uintptr_t a1;    // Function argument/return value
uintptr_t a2;    // Function argument
uintptr_t a3;    // Function argument
uintptr_t a4;    // Function argument
uintptr_t a5;    // Function argument
uintptr_t a6;    // Function argument
uintptr_t a7;    // Function argument
uintptr_t s2;    // Saved register
uintptr_t s3;    // Saved register
uintptr_t s4;    // Saved register
uintptr_t s5;    // Saved register
uintptr_t s6;    // Saved register
uintptr_t s7;    // Saved register
uintptr_t s8;    // Saved register
uintptr_t s9;    // Saved register
uintptr_t s10;   // Saved register
uintptr_t s11;   // Saved register
uintptr_t t3;    // Temporary
uintptr_t t4;    // Temporary
uintptr_t t5;    // Temporary
uintptr_t t6;    // Temporary
};
struct trapframe {
struct pushregs gpr;
uintptr_t status;
uintptr_t epc;
uintptr_t badvaddr;
uintptr_t cause;
};
```

struct trapframeç»“æ„ä½“å¦‚ä¸Šæ‰€ç¤ºï¼Œstruct trapframe æè¿°äº†å½“å‘ç”Ÿtrapï¼ˆä¸­æ–­ã€å¼‚å¸¸æˆ–ç³»ç»Ÿè°ƒç”¨ï¼‰æ—¶ï¼Œä¿å­˜å¤„ç†å™¨çŠ¶æ€çš„ç»“æ„ã€‚

- å…¶ç»“æ„ä½“ä¸­çš„struct pushregs gprç”¨æ¥ä¿å­˜é€šç”¨å¯„å­˜å™¨çš„çŠ¶æ€ï¼Œä»¥ä¾¿å¤„ç†å®Œæˆåæ¢å¤ã€‚
    
    struct pushregsåˆåŒ…æ‹¬ï¼š
    zeroï¼šæ’å®šä¸º 0 çš„å¯„å­˜å™¨ã€‚
    raï¼šè¿”å›åœ°å€ï¼ˆå‡½æ•°è°ƒç”¨çš„è¿”å›ä½ç½®ï¼‰ã€‚
    spï¼šæ ˆæŒ‡é’ˆï¼ˆæŒ‡å‘å½“å‰æ ˆçš„é¡¶ç«¯ï¼‰ã€‚
    gpï¼šå…¨å±€æŒ‡é’ˆï¼ˆæŒ‡å‘å…¨å±€æ•°æ®æ®µï¼‰ã€‚
    tpï¼šçº¿ç¨‹æŒ‡é’ˆï¼ˆç”¨äºçº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼‰ã€‚
    t0-t6ï¼šä¸´æ—¶å¯„å­˜å™¨ã€‚
    s0-s11ï¼šä¿å­˜å¯„å­˜å™¨ï¼ˆéœ€è¦åœ¨å‡½æ•°è°ƒç”¨é—´ä¿æŒå€¼ï¼‰ã€‚
    a0-a7ï¼šå‡½æ•°å‚æ•°æˆ–è¿”å›å€¼å¯„å­˜å™¨ã€‚
    
- uintptr_t statusç”¨äºä¿å­˜ CPU çš„çŠ¶æ€å¯„å­˜å™¨å€¼ï¼ˆå¦‚ä¸­æ–­ä½¿èƒ½ä½ã€ç‰¹æƒçº§ä½ç­‰ï¼‰æ¥åˆ¤æ–­å½“å‰ä¸Šä¸‹æ–‡æ˜¯å†…æ ¸æ€è¿˜æ˜¯ç”¨æˆ·æ€ã€‚
- uintptr_t epcæ˜¯å¼‚å¸¸ç¨‹åºè®¡æ•°å™¨ï¼Œç”¨æ¥ä¿å­˜å‘ç”Ÿå¼‚å¸¸æˆ–ä¸­æ–­æ—¶çš„ç¨‹åºè®¡æ•°å™¨åœ°å€ã€‚æŒ‡ç¤ºè§¦å‘é™·é˜±çš„æŒ‡ä»¤ä½ç½®ï¼Œå¤„ç†å®Œæˆåå¯ä»¥ä»è¯¥ä½ç½®ç»§ç»­æ‰§è¡Œã€‚
- uintptr_t badvaddrç”¨æ¥ä¿å­˜å¼‚å¸¸åœ°å€ï¼Œä¾‹å¦‚è§¦å‘éæ³•å†…å­˜è®¿é—®æ—¶çš„åœ°å€ã€‚åœ¨é¡µé”™è¯¯ç­‰å†…å­˜å¼‚å¸¸ä¸­ï¼ŒæŒ‡ç¤ºå‡ºé”™çš„å†…å­˜åœ°å€ï¼Œä¾¿äºå¤„ç†å’Œè¯Šæ–­ã€‚
- uintptr_t causeç”¨æ¥ä¿å­˜é™·é˜±çš„åŸå› ä»£ç ï¼ŒæŒ‡ç¤ºtrapç±»å‹ï¼Œå¹¶åˆ†å‘ç»™å¯¹åº”çš„å¤„ç†å‡½æ•°ã€‚

<aside>
ğŸ’¡

ä¸ context çš„åŒºåˆ«
**trapframe**ï¼š
ä¸»è¦ç”¨äºä¿å­˜ä¸­æ–­ã€å¼‚å¸¸æˆ–ç³»ç»Ÿè°ƒç”¨å‘ç”Ÿæ—¶çš„ä¸Šä¸‹æ–‡ï¼Œä¿å­˜çš„ä¿¡æ¯è¾ƒä¸ºå…¨é¢ï¼ˆåŒ…æ‹¬ statusã€epc ç­‰ï¼‰ã€‚
æ˜¯è¿›ç¨‹åˆ‡æ¢ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œä½†æ›´å¤šç”¨äºä¸­æ–­å¤„ç†ã€‚
**context**ï¼š
ä¸“æ³¨äºä¿å­˜è¿›ç¨‹åˆ‡æ¢æ—¶çš„é€šç”¨å¯„å­˜å™¨çŠ¶æ€ã€‚

</aside>

### ç»ƒä¹ 2ï¼š**ä¸ºæ–°åˆ›å»ºçš„å†…æ ¸çº¿ç¨‹åˆ†é…èµ„æºï¼ˆéœ€è¦ç¼–ç ï¼‰**

> åˆ›å»ºä¸€ä¸ªå†…æ ¸çº¿ç¨‹éœ€è¦åˆ†é…å’Œè®¾ç½®å¥½å¾ˆå¤šèµ„æºã€‚kernel_thread å‡½æ•°é€šè¿‡è°ƒç”¨ **do_fork** å‡½æ•°å®Œæˆå…·ä½“å†…æ ¸çº¿ç¨‹çš„åˆ›å»ºå·¥ä½œã€‚do_kernel å‡½æ•°ä¼šè°ƒç”¨ alloc_proc å‡½æ•°æ¥åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ªè¿›ç¨‹æ§åˆ¶å—ï¼Œä½† alloc_proc åªæ˜¯æ‰¾åˆ°äº†ä¸€å°å—å†…å­˜ç”¨ä»¥è®°å½•è¿›ç¨‹çš„å¿…è¦ä¿¡æ¯ï¼Œå¹¶æ²¡æœ‰å®é™…åˆ†é…è¿™äº›èµ„æºã€‚ucore ä¸€èˆ¬é€šè¿‡ do_fork å®é™…åˆ›å»ºæ–°çš„å†…æ ¸çº¿ç¨‹ã€‚do_fork çš„ä½œç”¨æ˜¯ï¼Œåˆ›å»ºå½“å‰å†…æ ¸çº¿ç¨‹çš„ä¸€ä¸ªå‰¯æœ¬ï¼Œå®ƒä»¬çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€ä»£ç ã€æ•°æ®éƒ½ä¸€æ ·ï¼Œä½†æ˜¯å­˜å‚¨ä½ç½®ä¸åŒã€‚å› æ­¤ï¼Œæˆ‘ä»¬**å®é™…éœ€è¦â€forkâ€çš„ä¸œè¥¿å°±æ˜¯ stack å’Œ trapframe**ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œéœ€è¦ç»™æ–°å†…æ ¸çº¿ç¨‹åˆ†é…èµ„æºï¼Œå¹¶ä¸”å¤åˆ¶åŸè¿›ç¨‹çš„çŠ¶æ€ã€‚ä½ éœ€è¦å®Œæˆåœ¨ kern/process/proc.c ä¸­çš„ do_fork å‡½æ•°ä¸­çš„å¤„ç†è¿‡ç¨‹ã€‚å®ƒçš„å¤§è‡´æ‰§è¡Œæ­¥éª¤åŒ…æ‹¬ï¼š
> 
> - è°ƒç”¨ alloc_procï¼Œé¦–å…ˆè·å¾—ä¸€å—ç”¨æˆ·ä¿¡æ¯å—ã€‚
> - ä¸ºè¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆã€‚
> - å¤åˆ¶åŸè¿›ç¨‹çš„å†…å­˜ç®¡ç†ä¿¡æ¯åˆ°æ–°è¿›ç¨‹ï¼ˆä½†å†…æ ¸çº¿ç¨‹ä¸å¿…åšæ­¤äº‹ï¼‰
> - å¤åˆ¶åŸè¿›ç¨‹ä¸Šä¸‹æ–‡åˆ°æ–°è¿›ç¨‹
> - å°†æ–°è¿›ç¨‹æ·»åŠ åˆ°è¿›ç¨‹åˆ—è¡¨
> - å”¤é†’æ–°è¿›ç¨‹
> - è¿”å›æ–°è¿›ç¨‹å·
> è¯·åœ¨å®éªŒæŠ¥å‘Šä¸­ç®€è¦è¯´æ˜ä½ çš„è®¾è®¡å®ç°è¿‡ç¨‹ã€‚è¯·å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š
> â€¢ è¯·è¯´æ˜ ucore æ˜¯å¦åšåˆ°ç»™æ¯ä¸ªæ–° fork çš„çº¿ç¨‹ä¸€ä¸ªå”¯ä¸€çš„ idï¼Ÿè¯·è¯´æ˜ä½ çš„åˆ†æå’Œç†ç”±ã€‚
> 

1. å®Œå–„do_forkå‡½æ•°ï¼š
```c
    // 1.è°ƒç”¨alloc_procåˆ†é…ä¸€ä¸ªproc_struct
    proc = alloc_proc();
    if (proc == NULL) // å¦‚æœåˆ†é…å¤±è´¥
        goto fork_out;  // è¿”å›å†…å­˜ä¸è¶³é”™è¯¯
    proc->parent = current; // è®¾ç½®å­è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ä¸ºå½“å‰è¿›ç¨‹
    // 2.è°ƒç”¨setup_kstackä¸ºå­è¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆ
    if (setup_kstack(proc) != 0) 
        goto bad_fork_cleanup_proc; // å¦‚æœåˆ†é…å¤±è´¥ï¼Œæ¸…ç†å·²åˆ†é…çš„ proc_struct

     // 3. è°ƒç”¨ copy_mm å‡½æ•°ï¼Œå¤åˆ¶æˆ–å…±äº«çˆ¶è¿›ç¨‹çš„å†…å­˜ç®¡ç†ä¿¡æ¯
    if (copy_mm(clone_flags, proc) != 0) 
        goto bad_fork_cleanup_kstack; // å¦‚æœå¤±è´¥ï¼Œæ¸…ç†å·²åˆ†é…çš„å†…æ ¸æ ˆ  

    // 4. è°ƒç”¨copy_thread()å‡½æ•°å¤åˆ¶çˆ¶è¿›ç¨‹çš„ä¸­æ–­å¸§å’Œä¸Šä¸‹æ–‡ä¿¡æ¯åˆ°å­è¿›ç¨‹
    copy_thread(proc, stack, tf);

    // 5. å°†å­è¿›ç¨‹çš„proc_structæ’å…¥hash_list && proc_list
    bool intr_flag;
    local_intr_save(intr_flag); // å…³é—­ä¸­æ–­ï¼Œä¿è¯æ“ä½œçš„åŸå­æ€§
    
    proc->pid = get_pid(); // ä¸ºå­è¿›ç¨‹åˆ†é…å”¯ä¸€çš„ PID
    hash_proc(proc); //å°†å­è¿›ç¨‹æ’å…¥å…¨å±€å“ˆå¸Œè¡¨å»ºç«‹æ˜ å°„
    list_add(&proc_list, &(proc->list_link)); // å°†å­è¿›ç¨‹æ’å…¥å…¨å±€é“¾è¡¨
    nr_process ++; // å¢åŠ å…¨å±€è¿›ç¨‹è®¡æ•°
    
    local_intr_restore(intr_flag); // æ¢å¤ä¸­æ–­

    // 6.è°ƒç”¨wakeup_procä½¿æ–°å­è¿›ç¨‹RUNNABLE
    wakeup_proc(proc);

    // 7.ä½¿ç”¨å­è¿›ç¨‹pidè®¾ç½®è·å–å€¼
    ret = proc->pid;
  
```
2. ucoreå¯ä»¥åšåˆ°ç»™æ¯ä¸ªæ–°forkçš„çº¿ç¨‹ä¸€ä¸ªå”¯ä¸€çš„idã€‚ucoreåœ¨æ¯æ¬¡åˆ›å»ºæ–°çš„å†…æ ¸è¿›ç¨‹æ—¶ï¼Œéƒ½ä¼šè°ƒç”¨proc.cä¸­get_pidå‡½æ•°ï¼Œä¸ºæ–°è¿›ç¨‹åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„pidï¼Œä½œä¸ºæ–°è¿›ç¨‹çš„proc->pidå­—æ®µã€‚get_pidå‡½æ•°å¦‚ä¸‹ï¼š

```c
static int
get_pid(void) {
    static_assert(MAX_PID > MAX_PROCESS);
    struct proc_struct *proc;
    list_entry_t *list = &proc_list, *le;
    static int next_safe = MAX_PID, last_pid = MAX_PID;
    if (++ last_pid >= MAX_PID) {
        last_pid = 1;
        goto inside;
    }
    if (last_pid >= next_safe) {
    inside:
        next_safe = MAX_PID;
    repeat:
        le = list;
        while ((le = list_next(le)) != list) {
            proc = le2proc(le, list_link);
            if (proc->pid == last_pid) {
                if (++ last_pid >= next_safe) {
                    if (last_pid >= MAX_PID) {
                        last_pid = 1;
                    }
                    next_safe = MAX_PID;
                    goto repeat;
                }
            }
            else if (proc->pid > last_pid && next_safe > proc->pid) {
                next_safe = proc->pid;
            }
        }
    }
    return last_pid;
}
```

- å‡½æ•°ä¸­é¦–å…ˆä½¿ç”¨static_assertå®ç¡®ä¿MAX_PIDå¤§äºMAX_PROCESSï¼Œä¿è¯æœ‰è¶³å¤Ÿçš„PIDå¯ç”¨ã€‚éšåå£°æ˜ç›¸å…³å˜é‡ï¼Œå¦‚next_safeå’Œlast_pidï¼Œç”¨äºè·Ÿè¸ªä¸‹ä¸€ä¸ªå®‰å…¨çš„PIDä»¥åŠä¸Šä¸€æ¬¡åˆ†é…çš„PIDã€‚

- é€’å¢last_pidï¼Œå¦‚æœè¾¾åˆ°MAX_PIDï¼Œåˆ™å°†å…¶é‡ç½®ï¼Œå¹¶è·³è½¬åˆ°insideã€‚å¦‚æœlast_pidå¤§äºç­‰äºnext_safeï¼ˆlast_pidå·²ç»è¢«ä½¿ç”¨ï¼‰ï¼Œåˆ™å°†next_safeè®¾ç½®ä¸ºMAX_PIDï¼Œè¿›å…¥repeatå¾ªç¯ï¼šéå†è¿›ç¨‹é“¾è¡¨ï¼Œæ£€æŸ¥å½“å‰è¿›ç¨‹çš„ ID æ˜¯å¦ç­‰äºlast_pidï¼Œå¦‚æœç›¸ç­‰ï¼Œåˆ™é€’å¢last_pidã€‚åŒæ—¶ï¼Œæ›´æ–°next_safeä¸ºå½“å‰è¿›ç¨‹ä¸­æœ€å¤§çš„PIDå€¼ã€‚

- æœ€åï¼Œå½“æ‰¾åˆ°ä¸€ä¸ªæ²¡æœ‰è¢«å…¶ä»–è¿›ç¨‹ä½¿ç”¨çš„last_pidæ—¶ï¼Œè¿™ä¸ªå€¼å°±è¢«è¿”å›ä½œä¸ºæ–°åˆ†é…çš„PIDï¼Œå› æ­¤å”¯ä¸€ã€‚

### ç»ƒä¹ 3ï¼š**ç¼–å†™ proc_run å‡½æ•°ï¼ˆéœ€è¦ç¼–ç ï¼‰**

> proc_run ç”¨äºå°†æŒ‡å®šçš„è¿›ç¨‹åˆ‡æ¢åˆ° CPU ä¸Šè¿è¡Œã€‚å®ƒçš„å¤§è‡´æ‰§è¡Œæ­¥éª¤åŒ…æ‹¬ï¼š 
â€¢ æ£€æŸ¥è¦åˆ‡æ¢çš„è¿›ç¨‹æ˜¯å¦ä¸å½“å‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ç›¸åŒï¼Œå¦‚æœç›¸åŒåˆ™ä¸éœ€è¦åˆ‡æ¢ã€‚
â€¢ ç¦ ç”¨ ä¸­ æ–­ã€‚ ä½  å¯ ä»¥ ä½¿ ç”¨/kern/sync/sync.h ä¸­ å®š ä¹‰ å¥½ çš„ å® local_intr_save(x) å’Œ
local_intr_restore(x) æ¥å®ç°å…³ã€å¼€ä¸­æ–­ã€‚
â€¢ åˆ‡æ¢å½“å‰è¿›ç¨‹ä¸ºè¦è¿è¡Œçš„è¿›ç¨‹ã€‚
â€¢ åˆ‡æ¢é¡µè¡¨ï¼Œä»¥ä¾¿ä½¿ç”¨æ–°è¿›ç¨‹çš„åœ°å€ç©ºé—´ã€‚/libs/riscv.h ä¸­æä¾›äº† lcr3(unsigned int cr3)
å‡½æ•°ï¼Œå¯å®ç°ä¿®æ”¹ CR3 å¯„å­˜å™¨å€¼çš„åŠŸèƒ½ã€‚
â€¢ å®ç°ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚/kern/process ä¸­å·²ç»é¢„å…ˆç¼–å†™å¥½äº† switch.Sï¼Œå…¶ä¸­å®šä¹‰äº† switch_to() å‡½
æ•°ã€‚å¯å®ç°ä¸¤ä¸ªè¿›ç¨‹çš„ context åˆ‡æ¢ã€‚
â€¢ å…è®¸ä¸­æ–­ã€‚
è¯·å›ç­”å¦‚ä¸‹é—®é¢˜ï¼š
â€¢ åœ¨æœ¬å®éªŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºä¸”è¿è¡Œäº†å‡ ä¸ªå†…æ ¸çº¿ç¨‹ï¼Ÿ
å®Œæˆä»£ç ç¼–å†™åï¼Œç¼–è¯‘å¹¶è¿è¡Œä»£ç ï¼šmake qemu
å¦‚æœå¯ä»¥å¾—åˆ°å¦‚é™„å½• A æ‰€ç¤ºçš„æ˜¾ç¤ºå†…å®¹ï¼ˆä»…ä¾›å‚è€ƒï¼Œä¸æ˜¯æ ‡å‡†ç­”æ¡ˆè¾“å‡ºï¼‰ï¼Œåˆ™åŸºæœ¬æ­£ç¡®ã€‚
> 

1.  æŒ‰å®éªŒè¦æ±‚çš„æ­¥éª¤å®Œæˆproc_runå‡½æ•°ï¼Œä»£ç å¦‚ä¸‹
```c
void
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag; 
        struct proc_struct *prev = current;
        current = proc;
        local_intr_save(intr_flag); // ä¿æŒå½“å‰ä¸­æ–­çŠ¶æ€åˆ°intr_flagå¹¶ç¦ç”¨ä¸­æ–­
        {
            // å½“å‰è¿›ç¨‹è®¾ä¸ºå¾…è°ƒåº¦çš„è¿›ç¨‹
            current = proc;
            // é¡µç›®å½•è¡¨åŒ…å«äº†è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„æ˜ å°„å…³ç³»,å°†å½“å‰è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´æ˜ å°„å…³ç³»åˆ‡æ¢ä¸ºæ–°è¿›ç¨‹çš„æ˜ å°„å…³ç³».
            // ç¡®ä¿æŒ‡ä»¤å’Œæ•°æ®çš„åœ°å€è½¬æ¢æ˜¯åŸºäºæ–°è¿›ç¨‹çš„é¡µç›®å½•è¡¨è¿›è¡Œçš„
            // å°†å½“å‰çš„cr3å¯„å­˜å™¨æ”¹ä¸ºéœ€è¦è¿è¡Œè¿›ç¨‹çš„é¡µç›®å½•è¡¨ï¼Œå…¶å®å°±æ˜¯æ›´æ–°é¡µè¡¨
            lcr3(current->cr3);
            // è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œä¿å­˜åŸçº¿ç¨‹çš„å¯„å­˜å™¨å¹¶æ¢å¤å¾…è°ƒåº¦çº¿ç¨‹çš„å¯„å­˜å™¨
            switch_to(&(prev->context), &(current->context));
        }
        local_intr_restore(intr_flag); // æ¢å¤ä¸­æ–­çŠ¶æ€
    }
}
```
2. åœ¨æœ¬å®éªŒçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºä¸”è¿è¡Œäº†å‡ ä¸ªå†…æ ¸çº¿ç¨‹ï¼Ÿ

é€šè¿‡kernel_threadå‡½æ•°ã€proc_initå‡½æ•°ç­‰çš„å®šä¹‰å¯çŸ¥ï¼Œæœ¬æ¬¡å®éªŒå…±å»ºç«‹äº†ä¸¤ä¸ªå†…æ ¸çº¿ç¨‹ï¼Œåˆ†åˆ«æ˜¯idleprocå†…æ ¸çº¿ç¨‹å’Œinitprocå†…æ ¸çº¿ç¨‹ã€‚

- idleprocå†…æ ¸çº¿ç¨‹æ˜¯æœ€åˆçš„å†…æ ¸çº¿ç¨‹ï¼Œå…¶å®Œæˆå†…æ ¸ä¸­å„ä¸ªå­çº¿ç¨‹çš„åˆ›å»ºä»¥åŠåˆå§‹åŒ–ï¼Œç”¨äºè°ƒåº¦å…¶ä»–è¿›ç¨‹çº¿ç¨‹ï¼Œä¹Ÿä»£è¡¨ç©ºé—²çŠ¶æ€ä¸‹çš„ CPU è¿è¡Œã€‚å…¶pid=0ï¼ŒçŠ¶æ€ä¸º PROC_RUNNABLEï¼Œneed_resched=1ï¼Œè¡¨ç¤ºéœ€è¦è¿›è¡Œè°ƒåº¦ã€‚
- initprocå†…æ ¸çº¿ç¨‹æ˜¯ç¬¬äºŒä¸ªå†…æ ¸çº¿ç¨‹ï¼Œé€šè¿‡ kernel_thread å‡½æ•°åˆ›å»ºï¼Œä¼šè°ƒç”¨init_mainå‡½æ•°ï¼Œè¯¥çº¿ç¨‹ä¸»è¦æ˜¯ä¸ºäº†æ˜¾ç¤ºå®éªŒæˆåŠŸå¹¶æ‰“å°å‡ºå­—ç¬¦ä¸²"hello world"ã€‚



### **æ‰©å±•ç»ƒä¹  Challengeï¼š**

> è¯´æ˜è¯­å¥ local_intr_save(intr_flag);....local_intr_restore(intr_flag); æ˜¯å¦‚ä½•å®ç°å¼€å…³ä¸­æ–­çš„ï¼Ÿ
> 

```c
//å®šä¹‰ä¸€ä¸ªå†…è”å‡½æ•° __intr_saveï¼Œç”¨äºä¿å­˜å½“å‰ä¸­æ–­çŠ¶æ€å¹¶ç¦ç”¨ä¸­æ–­
static inline bool __intr_save(void) {
    if (read_csr(sstatus) & SSTATUS_SIE) {
        // æ£€æŸ¥ sstatus å¯„å­˜å™¨çš„ SIE ä½æ˜¯å¦ä¸º 1ï¼Œè¡¨ç¤ºä¸­æ–­æ˜¯å¦å¯ç”¨
        intr_disable();// å¦‚æœ SIE ä½ä¸º 1ï¼Œåˆ™è°ƒç”¨ intr_disable å‡½æ•°ç¦ç”¨ä¸­æ–­
        return 1;
    }
    return 0;
}

static inline void __intr_restore(bool flag) {// ç”¨äºæ ¹æ®ä¿å­˜çš„çŠ¶æ€æ¢å¤ä¸­æ–­
    if (flag) {// æ£€æŸ¥ flag å‚æ•°æ˜¯å¦ä¸º true
        intr_enable();// å¦‚æœ flag ä¸º trueï¼Œåˆ™è°ƒç”¨ intr_enable å‡½æ•°é‡æ–°å¯ç”¨ä¸­æ–­
    }
}

#define local_intr_save(x) \  //ç”¨äºä¿å­˜å½“å‰ä¸­æ–­çŠ¶æ€å¹¶ç¦ç”¨ä¸­æ–­
    do {                   \
        x = __intr_save(); \  //è°ƒç”¨ __intr_save å‡½æ•°ï¼Œå°†å½“å‰ä¸­æ–­çŠ¶æ€ä¿å­˜åˆ°å˜é‡ x ä¸­ï¼ŒåŒæ—¶ç¦ç”¨ä¸­æ–­
    } while (0)
#define local_intr_restore(x) __intr_restore(x);//å®šä¹‰ä¸€ä¸ªå® local_intr_restoreï¼Œæ ¹æ®ä¿å­˜çš„çŠ¶æ€ x æ¢å¤ä¸­æ–­

void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }

void intr_disable(void) { clear_csr(sstatus, SSTATUS_SIE); }
```

local_intr_save(intr_flag) å’Œ local_intr_restore(intr_flag) ç”¨äºå®ç°ä¸­æ–­çš„å¼€å…³ã€‚local_intr_save ä¼šä¿å­˜å½“å‰çš„ä¸­æ–­çŠ¶æ€ï¼ˆå¯ç”¨æˆ–ç¦ç”¨ï¼‰åˆ° intr_flagï¼Œå¹¶ç¦ç”¨ä¸­æ–­ï¼Œç¡®ä¿åç»­çš„å…³é”®ä»£ç æ®µä¸è¢«ä¸­æ–­æ‰“æ–­ï¼›local_intr_restore åˆ™æ ¹æ®ä¿å­˜çš„çŠ¶æ€ intr_flag æ¢å¤ä¸­æ–­ï¼Œä½¿å…¶æ¢å¤ä¸ºåŸæ¥çš„çŠ¶æ€ã€‚è¿™ä¸€æœºåˆ¶é€šè¿‡æ“ä½œ RISC-V çš„ sstatus å¯„å­˜å™¨ä¸­çš„ SIE ä½ï¼ˆSupervisor Interrupt Enableï¼‰å®ç°ï¼Œä¸­æ–­å¼€å¯æ—¶è®¾ç½®è¯¥ä½ä¸º 1ï¼Œå…³é—­æ—¶æ¸…é™¤ä¸º 0ï¼Œä»è€Œæ§åˆ¶ä¸­æ–­çš„å¯ç”¨ä¸ç¦ç”¨ã€‚

###